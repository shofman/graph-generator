<html>
<head>
    <meta charset="utf-8" />
    <title>Puzzle Generator</title>
    <style>
      * { padding: 0; margin: 0; }
      canvas { background: #eee; display: block; margin: 0 auto; margin-top: 30; }
      button { width: 20px; height: 20px; }
    </style>
</head>
<body>

<canvas id="myCanvas" width="480" height="320"></canvas>
<canvas id="myCanvas2" width="480" height="320"></canvas>

<script type="text/javascript" src="./createLinesOnGrid.js"></script>
<script type="text/javascript" src="./generateNewGridForLayerPuzzle.js"></script>

<script>
const AleaRandomizer = seed => {
  function Mash() {
    var n = 4022871197
    return function(r) {
      for (var t, f, s, u = 0, e = 0.02519603282416938; u < r.length; u++)
        (s = r.charCodeAt(u)),
        (f = e * (n += s) - ((n * e) | 0)),
        (n = 4294967296 * ((t = f * ((e * n) | 0)) - (t | 0)) + (t | 0))
      return (n | 0) * 2.3283064365386963e-10
    }
  }
  return (function() {
    var m = Mash(),
      a = m(' '),
      b = m(' '),
      c = m(' '),
      x = 1
    ;(seed = seed.toString()), (a -= m(seed)), (b -= m(seed)), (c -= m(seed))
    a < 0 && a++, b < 0 && b++, c < 0 && c++
    return function() {
      var y = x * 2.3283064365386963e-10 + a * 2091639
      ;(a = b), (b = c)
      return (c = y - (x = y | 0))
    }
  })()
}

const canvas = document.getElementById('myCanvas')
const canvas2 = document.getElementById('myCanvas2')
const ctx = canvas.getContext('2d')
const ctx2 = canvas2.getContext('2d')
let gridList = []
const pixelSize = 20

const gridSpace = 1
const gridNumber = 6

let gridYLength = gridNumber * gridSpace + gridNumber * gridSpace
let gridXLength = gridNumber * gridSpace + gridNumber * gridSpace

canvas.height = gridYLength * pixelSize +  (gridNumber * gridSpace * pixelSize)
canvas.width = gridXLength * pixelSize + (gridNumber * gridSpace * pixelSize)

const generateKey = (x,y) => `${x},${y}`

// Simple grid
// Density = 0.07471264367816093

let initialGrid = [
  // [0, 0, 3, 3, 0, 0],
  // [0, 3, 3, 3, 0, 0],
  // [3, 0, 0, 3, 0, 0],
  // [3, 3, 3, 3, 3, 0],
  // [5, 0, 0, 0, 0, 0],
]

// Crisscrossing entries
// Density = 0.09895833333333333

initialGrid = [
  [0, 3, 0, 0, 0, 0],
  [0, 3, 3, 0, 0, 0],
  [3, 3, 3, 0, 0, 0],
  [0, 3, 3, 3, 5, 0],
  [0, 0, 3, 3, 0, 0],
  [0, 0, 3, 3, 3, 0],
  [0, 0, 0, 3, 3, 3],
  [0, 0, 0, 3, 0, 0],
]

// Starting points from within grid
// Density = 0.1346153846153846

// initialGrid = [
//   [0, 0, 0, 0, 0, 3, 0, 0],
//   [0, 0, 5, 3, 3, 3, 0, 0],
//   [0, 0, 0, 3, 3, 3, 3, 3],
//   [0, 0, 0, 3, 3, 3, 3, 3],
//   [0, 0, 0, 3, 3, 0, 0, 0],
//   [0, 3, 3, 3, 3, 0, 0, 0],
//   [3, 3, 3, 3, 3, 0, 0, 0],
//   [0, 0, 0, 3, 3, 0, 0, 0],
// ]

for (let i=0; i<gridYLength; i++) {
  initialGrid.push(Array.apply(null, Array(gridXLength)).map(() => {
    return 0
  }))
}

// Second grid seeds
const broken = 0.13211651171095662
const weird = 0.8814176675958372
const huh = 0.9414135727191293
const solved = 0.9311797150098673
const needToFixBacktracking = 0.7037516700656562

// Third grid seeds
const infinite = 0.8270123205982178
const infinite2 = 0.5020871473412547
const fucked = 0.45286728697492507


const tiedLargest = 0.2996170901896136
const breakThisDown =  0.949010289749602
const howToHandle = 0.7210721903502999
const badTargetPlacement = 0.27211505962386684
const chunky = 0.6757205201354943
const multipleTargetsWithEvenLengths = 0.33285831629572726
const noTargets = 0.4598295234421774
const reallyLongTail = 0.8742797946667888
const handle = 0.16586225158162837
const brokenAgain =  0.8807449728181744
const reallyDense = 0.006649334400887774
const goodSeed = 0.16134528824178074
const fuckingUseless = 0.6013755322878005

const seed = needToFixBacktracking//Math.random()
console.log('seed', seed)
const randomizer = AleaRandomizer(seed)
// const distanceVisitedGraph = undefined

const shouldGenerateNew = false

const { grid, shavedGrid, distanceVisitedGraph, floodGraph } = generateNewGrid(initialGrid, randomizer)

let otherGrid

if (shouldGenerateNew) {
  initialGrid = shavedGrid
  otherGrid = grid
}

let currentGrid = initialGrid

const arrayCopy = array => JSON.parse(JSON.stringify(array))

gridList.push(initialGrid)


const buttonPositions = []

function isIntersect(point, circle) {
  return Math.sqrt(Math.pow(point.x-circle.x, 2) + Math.pow(point.y - circle.y, 2)) < circle.radius
}

canvas.addEventListener('click', (e) => {
  function relMouseCoords(event){
    let totalOffsetX = 0
    let totalOffsetY = 0
    let canvasX = 0
    let canvasY = 0
    let currentElement = canvas

    do{
      totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft
      totalOffsetY += currentElement.offsetTop - currentElement.scrollTop
      currentElement = currentElement.offsetParent
    }
    while(currentElement)

    canvasX = event.pageX - totalOffsetX
    canvasY = event.pageY - totalOffsetY

    return {x:canvasX, y:canvasY}
  }

  const mousePoint = relMouseCoords(e)

  buttonPositions.forEach(circle => {
    if (isIntersect(mousePoint, circle)) {
      circle.onClick()
    }
  })
})

const colorGroups = ['green', 'yellow', 'orange', 'purple', 'cyan', 'red', 'white', 'black']
const drawColors = false
let shouldDrawTarget = true
const shouldPauseOnDraw = false
const shouldPauseOnDebugDraw = true
const shouldDrawGridLines = true
const drawDistances = false

const canReachTargetWithSingleBlock = () => false
const hasResultWithoutBlock = () => false
const hasCreatedImpossibleWin = () => false

// const hasBlock

const checkIfStateIsBroken = () => canReachTargetWithSingleBlock() || hasResultWithoutBlock() || hasCreatedImpossibleWin()

const checkGridForWin = (results, currentGrid) => {
  const totalRemainingBlocks = currentGrid.reduce((acc, current, rowIndex) => {
    const results = current
      .map((item, index) => item === obstacle ? index : -1)
      .filter(colIndex => colIndex !== -1)
      .map(colIndex => generateKey(colIndex, rowIndex))
    return acc.concat(results)
  }, [])

  const totalBlocksWithHints = Object.keys(results)

  const allRemainingBlocksHaveHints = totalRemainingBlocks.every(item => totalBlocksWithHints.includes(item))
  const allHintsHaveBlocks = totalBlocksWithHints.every(item => totalRemainingBlocks.includes(item))

  return allRemainingBlocksHaveHints && allHintsHaveBlocks
}

const getOtherDirection = currentDirection => currentDirection === 'horizontal' ? 'vertical' : 'horizontal'

const getRemovalFunc = index => index === 0 ? 'shift' : 'pop'

const getEndBlock = (currentLine, index) => {
  if (index === 0) {
    return currentLine[currentLine.length - 1]
  } else {
    return currentLine[0]
  }
}

const stripOutCurrentEntry = currentEntry => line => {
  const removeEntry = (startIndex, endIndex) => line => {
    return line.length > 2 ? line.slice(startIndex, endIndex) : []
  }

  const removeLastEntry = removeEntry(0, line.length - 1)
  const removeFirstEntry = removeEntry(1, line.length)

  if (line.includes(currentEntry)) {
    if (line.indexOf(currentEntry) === line.length - 1) {
      return removeLastEntry(line)
    } else if (line.indexOf(currentEntry) === 0) {
      return removeFirstEntry(line, 1, line.length)
    } else {
      // Third case - the offending entry is in the middle (we treat this like we will slide over it)
      // But it cannot be used in another case
      line.splice(line.indexOf(currentEntry), 1)
      return line
    }
  }
  return line
}

const getAllPossibleLineCases = ({ currentLine, currentDirection, endBlock, gridLineInfo, currentGrid, currentResults, currentIntersectionPoints }) => {
  const currentLineLength = currentLine.length

  const createLineCase = ({ blockValue, intersectionPoints }) => ({
    currentLine: arrayCopy(currentLine),
    blockValue,
    direction: currentDirection,
    intersectionPoints,
    targetBlock: endBlock,
    currentGrid: arrayCopy(currentGrid),
    currentResults: arrayCopy(currentResults),
    gridLineInfo: arrayCopy(gridLineInfo)
  })

  const intersectingBlocks = currentLine.filter(point => doesPointIntersect(gridLineInfo, point) && point !== endBlock)
  const possibleCases = getAllSubsets(intersectingBlocks)

  return possibleCases.reverse().map(intersectingCase => {
    return createLineCase({
      blockValue: currentLineLength - intersectingCase.length,
      intersectionPoints: currentIntersectionPoints.concat(intersectingCase),
    })
  }).filter(newLineCase => newLineCase.blockValue > 0)
}

const modifyGridWithCurrentLine = (currentCase, removal, target, lineIndex) => {
  let { intersectionPoints, gridLineInfo, currentLine, direction, blockValue, currentResults, currentGrid } = currentCase

  const newCurrentLine = arrayCopy(currentLine)

  while(newCurrentLine.length) {
    const currentEntry = newCurrentLine[removal]()
    if (!newCurrentLine.length) {
      if (currentGrid[target.targetRow][target.targetCol] !== targetBlock) {
        currentGrid[target.targetRow][target.targetCol] = emptySpace
      }

      currentResults[currentEntry] = {
        value: blockValue,
        direction,
      }

      // Remove lines that cannot be used due to being added in this particular direction
      const otherDirection = getOtherDirection(direction)
      const otherLinesToCheck = gridLineInfo[otherDirection]

      if (otherLinesToCheck.some(line => line.includes(currentEntry))) {
        const linesWithCurrentEntryRemoved = otherLinesToCheck.map(stripOutCurrentEntry(currentEntry))
        gridLineInfo[otherDirection] = linesWithCurrentEntryRemoved
      }
    } else if (!doesPointIntersect(gridLineInfo, currentEntry)) {
      if (!Object.keys(currentResults).includes(currentEntry)) {
        const [removalCol, removalRow] = currentEntry.split(',')
        currentGrid[removalRow][removalCol] = emptySpace
      }
    }
  }
  gridLineInfo[direction].splice(lineIndex, 1)

  return Object.assign(currentCase, {
    currentGrid,
    currentResults,
    gridLineInfo,
    intersectionPoints,
  })
}

const doesPointIntersect = (gridLineInfo, currentEntry) => {
  return Object.keys(gridLineInfo).every(direction => {
    return gridLineInfo[direction].some(row => row.some(block => block === currentEntry))
  })
}

const isEndBlockEmpty = (endBlock, currentGrid) => {
  const [column, row] = endBlock.split(',').map(x => parseInt(x))
  return currentGrid[row][column] === emptySpace
}

const isEndBlockAlreadyUsed = (endBlock, results) => {
  return !!results[endBlock]
}

const getAllSubsets = arrayOfChildren =>
  arrayOfChildren.reduce(
    (subsets, value) => subsets.concat(
      subsets.map(set => [value,...set])
    ),
    [[]]
  )

const debugDraw = (currentGrid, results, override = false) => {
  drawBricks(currentGrid, ctx, false)
  drawHints(results)
  drawGridLines()
  if (shouldPauseOnDebugDraw && !override) {
    debugger // eslint-disable-line
  }
}

let drawTarget = {}

const backtrackingUnzip = (results, currentGrid, intersectionPoints, gridLineInfo, target) => {
  debugDraw(currentGrid, results, true)
  const isBroken = checkIfStateIsBroken()
  if (isBroken) return {}
  let isWinner = checkGridForWin(results, currentGrid)
  if (isWinner) {
    return { results, currentGrid }
  }

  let { targetRow, targetCol } = target
  drawTarget = target
  const key = generateKey(targetCol, targetRow)

  let currentLineInfo = {
    direction: undefined,
    index: undefined,
    line: undefined
  }

  // Assert there is only one direction this could have come from
  const validDirections = Object.keys(gridLineInfo).filter(direction => {
    return gridLineInfo[direction].filter((line, index) => {
      const containsTarget = line.includes(key)
      if (containsTarget) {
        currentLineInfo.line = arrayCopy(line)
        currentLineInfo.direction = direction
        currentLineInfo.index = index
      }
      return containsTarget
    }).length === 1
  })

  if (validDirections.length > 1 || currentLineInfo.line === undefined) {
    // console.log('we are returning early', validDirections.length > 1, currentLineInfo.line === undefined)
    return { results, currentGrid }
  }

  let targetIndex = currentLineInfo.line.indexOf(key)

  const {line: currentLine, direction: currentDirection } = currentLineInfo

  // Assert that the target is at the beginning/end of a line
  if (targetIndex !== 0 && targetIndex !== currentLine.length - 1) {
    // If not, we need to split the current line into multiple sections
    const shiftValue = randomizer() > .5 ? 0 : 1

    const firstChunk = currentLine.slice(0, targetIndex + shiftValue)
    const secondChunk = currentLine.slice(targetIndex + shiftValue)

    // remove the current troublesome line
    gridLineInfo[currentDirection].splice(currentLineInfo.index, 1)

    // replace with two new lines
    gridLineInfo[currentDirection].push(firstChunk)
    gridLineInfo[currentDirection].push(secondChunk)

    const chunkToUse = firstChunk.indexOf(key) !== -1 ? firstChunk : secondChunk

    // Update our details to use the target
    currentLineInfo.line = arrayCopy(chunkToUse)
    currentLineInfo.index = gridLineInfo[currentDirection].indexOf(chunkToUse)
    targetIndex = chunkToUse.indexOf(key)
  }

  const removal = getRemovalFunc(targetIndex)

  // Remove targetblock that we used to come in here
  currentLineInfo.line[removal]()

  const endBlock = getEndBlock(currentLineInfo.line, targetIndex)

  if (isEndBlockEmpty(endBlock, currentGrid) || isEndBlockAlreadyUsed(endBlock, results)) {
    // check to see if the directions match and adjust - should never get in here
    // if (endBlockAlreadyUsed && results[endBlock].direction === currentLineInfo.direction) {}
    return { results, currentGrid }
  }

  const listOfPossibleStates = getAllPossibleLineCases({ 
    currentLine: arrayCopy(currentLineInfo.line),
    currentDirection,
    endBlock,
    gridLineInfo,
    currentGrid,
    currentResults: arrayCopy(results),
    currentIntersectionPoints: arrayCopy(intersectionPoints),
  })

  if (!listOfPossibleStates.length) {
    return { results, currentGrid }
  }

  let currentCase = listOfPossibleStates.shift()
  currentCase = modifyGridWithCurrentLine(currentCase, removal, target, currentLineInfo.index)

  if (checkGridForWin(currentCase.currentResults, currentCase.currentGrid)) {
    return { results: currentCase.currentResults, currentGrid: currentCase.currentGrid }
  }

  // debugDraw(currentCase.currentGrid, currentCase.currentResults)

  while (currentCase.intersectionPoints.length) {
    const currentPoint = currentCase.intersectionPoints.pop()
    const splitPoint = currentPoint.split(',')
    const newTarget = { targetCol: splitPoint[0], targetRow: splitPoint[1] }

    const response = backtrackingUnzip(
      currentCase.currentResults,
      arrayCopy(currentCase.currentGrid),
      arrayCopy(currentCase.intersectionPoints),
      arrayCopy(currentCase.gridLineInfo),
      newTarget
    )

    if (checkGridForWin(response.results, response.currentGrid)) {
      return response
    }

    if (!currentCase.intersectionPoints.length && listOfPossibleStates.length) {
      currentCase = listOfPossibleStates.shift()
      currentCase = modifyGridWithCurrentLine(currentCase, removal, target, currentLineInfo.index)
      currentGrid = currentCase.currentGrid
      results = currentCase.currentResults
    }
  }

  return { results, currentGrid }
}

const lineGrid = createLines(initialGrid)

let targetRow = initialGrid.findIndex(row => row.some(block => block === targetBlock))
let targetCol = initialGrid[targetRow].findIndex(block => block === targetBlock)

let results = {}
draw()

const cursiveResult = backtrackingUnzip(results, initialGrid, [], lineGrid, { targetRow, targetCol })
results = cursiveResult.results
currentGrid = cursiveResult.currentGrid
shouldDrawTarget = false

function drawBricks(currentGrid, ctx, drawColors) {
  if (!currentGrid) return
  const drawBrick = ctx => (x, y, color) => {
    ctx.beginPath()
    ctx.rect(x, y, pixelSize, pixelSize)
    ctx.fillStyle = color
    ctx.fill()
    ctx.closePath()
  }

  const drawBrickFunc = drawBrick(ctx)
  ctx.clearRect(0, 0, canvas.width, canvas.height)

  for(var row=0; row<gridYLength; row++) {
    for(var column=0; column<gridXLength; column++) {
      var brickX = (column*(pixelSize))+(pixelSize / 2)
      var brickY = (row*(pixelSize))+(pixelSize / 2)

      if (parseInt(drawTarget.targetRow) === row && parseInt(drawTarget.targetCol) === column && shouldDrawTarget) {
        drawBrickFunc(brickX, brickY, 'green')
      } else if (drawColors && floodGraph[row][column].visited === true) {
        const index = floodGraph[row][column].searchGroup
        drawBrickFunc(brickX, brickY, colorGroups[index])
      } else if(currentGrid[row][column] === obstacle) {
        drawBrickFunc(brickX, brickY, '#0095DD')
      } else if (currentGrid[row][column] === targetBlock) {
        drawBrickFunc(brickX, brickY, 'red')
      }

      if (drawDistances && distanceVisitedGraph && distanceVisitedGraph[row][column] && distanceVisitedGraph[row][column].visited === true) {
        const distance = distanceVisitedGraph[row][column].distance
        ctx.beginPath()
        ctx.font = '8px Comic Sans MS'
        ctx.strokeStyle = 'black'
        ctx.strokeText(distance, column * pixelSize+(pixelSize - 3), row * pixelSize+(pixelSize))
        ctx.stroke()
        ctx.closePath()
      }
    }
  }
}

function drawHints(results) {
  if (results) {
    Object.keys(results).forEach(coordinate => {
      const value = results[coordinate].value
      const [column, row] = coordinate.split(',')
      ctx.beginPath()
      ctx.font = '8px Comic Sans MS'
      ctx.strokeStyle = 'black'
      ctx.strokeText(value, column * pixelSize+(pixelSize - 3), row * pixelSize+(pixelSize))
      ctx.stroke()
      ctx.closePath()
    })
  }
}

function drawGridLines() {
  for(var row=0; row<gridYLength; row++) {
    for(var col=0; col<gridXLength; col++) {
      if (row === 0) {
        ctx.beginPath()
        ctx.font = '8px Comic Sans MS'
        ctx.strokeStyle = 'black'
        ctx.strokeText(col, col * pixelSize+(pixelSize - 3), pixelSize / 3)
        ctx.stroke()
        ctx.closePath()
      }

      ctx.moveTo(col * pixelSize + (pixelSize / 2), row * pixelSize)
      ctx.lineTo(col * pixelSize + (pixelSize / 2), (row * pixelSize)+ (pixelSize))
      ctx.stroke()
    }

    ctx.beginPath()
    ctx.font = '8px Comic Sans MS'
    ctx.strokeStyle = 'black'
    ctx.strokeText(row, 0, row * pixelSize+(pixelSize))
    ctx.stroke()
    ctx.moveTo(0, row * pixelSize + pixelSize / 2)
    ctx.lineTo(gridXLength * pixelSize, (row * pixelSize) + pixelSize / 2)
    ctx.stroke()
    ctx.closePath()
  }
}


function checkForWin() {

}

function draw() {
  drawBricks(currentGrid, ctx, false)
  drawBricks(otherGrid, ctx2, drawColors)
  drawHints(results)
  if (shouldDrawGridLines) {
    drawGridLines()
  }
  checkForWin()
  if (shouldPauseOnDraw) {
    debugger // eslint-disable-line
  }
  requestAnimationFrame(draw)
}

draw()
</script>

</body>
</html>